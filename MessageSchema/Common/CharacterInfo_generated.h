// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_
#define FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Constant_generated.h"
#include "ItemInfo_generated.h"
#include "Type_generated.h"

namespace GenericBoson {
namespace Zozo {

struct StatPair;

struct TicketPair;

struct CharacterInfo;
struct CharacterInfoBuilder;
struct CharacterInfoT;

inline const ::flatbuffers::TypeTable *StatPairTypeTable();

inline const ::flatbuffers::TypeTable *TicketPairTypeTable();

inline const ::flatbuffers::TypeTable *CharacterInfoTypeTable();

enum Stat : int32_t {
  Stat_None = 0,
  Stat_MeleeAttack = 1,
  Stat_MeleeDefence = 2,
  Stat_RangeAttack = 3,
  Stat_RangeDefence = 4,
  Stat_MagicAttack = 5,
  Stat_MagicDefence = 6,
  Stat_Agility = 7,
  Stat_Accuracy = 8,
  Stat_Speed = 9,
  Stat_MIN = Stat_None,
  Stat_MAX = Stat_Speed
};

inline const Stat (&EnumValuesStat())[10] {
  static const Stat values[] = {
    Stat_None,
    Stat_MeleeAttack,
    Stat_MeleeDefence,
    Stat_RangeAttack,
    Stat_RangeDefence,
    Stat_MagicAttack,
    Stat_MagicDefence,
    Stat_Agility,
    Stat_Accuracy,
    Stat_Speed
  };
  return values;
}

inline const char * const *EnumNamesStat() {
  static const char * const names[11] = {
    "None",
    "MeleeAttack",
    "MeleeDefence",
    "RangeAttack",
    "RangeDefence",
    "MagicAttack",
    "MagicDefence",
    "Agility",
    "Accuracy",
    "Speed",
    nullptr
  };
  return names;
}

inline const char *EnumNameStat(Stat e) {
  if (::flatbuffers::IsOutRange(e, Stat_None, Stat_Speed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStat()[index];
}

enum Ticket : int32_t {
  Ticket_None = 0,
  Ticket_CaveDungeon = 1,
  Ticket_IslandDungeon = 2,
  Ticket_MIN = Ticket_None,
  Ticket_MAX = Ticket_IslandDungeon
};

inline const Ticket (&EnumValuesTicket())[3] {
  static const Ticket values[] = {
    Ticket_None,
    Ticket_CaveDungeon,
    Ticket_IslandDungeon
  };
  return values;
}

inline const char * const *EnumNamesTicket() {
  static const char * const names[4] = {
    "None",
    "CaveDungeon",
    "IslandDungeon",
    nullptr
  };
  return names;
}

inline const char *EnumNameTicket(Ticket e) {
  if (::flatbuffers::IsOutRange(e, Ticket_None, Ticket_IslandDungeon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTicket()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatPair FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t key_;
  int32_t padding0__;
  int64_t value_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StatPairTypeTable();
  }
  StatPair()
      : key_(0),
        padding0__(0),
        value_(0) {
    (void)padding0__;
  }
  StatPair(GenericBoson::Zozo::Stat _key, int64_t _value)
      : key_(::flatbuffers::EndianScalar(static_cast<int32_t>(_key))),
        padding0__(0),
        value_(::flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
  }
  GenericBoson::Zozo::Stat key() const {
    return static_cast<GenericBoson::Zozo::Stat>(::flatbuffers::EndianScalar(key_));
  }
  int64_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(StatPair, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TicketPair FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t key_;
  int32_t padding0__;
  int64_t value_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TicketPairTypeTable();
  }
  TicketPair()
      : key_(0),
        padding0__(0),
        value_(0) {
    (void)padding0__;
  }
  TicketPair(GenericBoson::Zozo::Ticket _key, int64_t _value)
      : key_(::flatbuffers::EndianScalar(static_cast<int32_t>(_key))),
        padding0__(0),
        value_(::flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
  }
  GenericBoson::Zozo::Ticket key() const {
    return static_cast<GenericBoson::Zozo::Ticket>(::flatbuffers::EndianScalar(key_));
  }
  int64_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(TicketPair, 16);

struct CharacterInfoT : public ::flatbuffers::NativeTable {
  typedef CharacterInfo TableType;
  int64_t id = 0;
  int64_t user_id = 0;
  std::string name{};
  int32_t level = 0;
  int32_t hp = 0;
  int32_t hp_max = 0;
  int32_t mp = 0;
  int32_t mp_max = 0;
  std::unique_ptr<GenericBoson::Zozo::Vector2F> position{};
  std::vector<GenericBoson::Zozo::StatPair> stats{};
  std::vector<GenericBoson::Zozo::TicketPair> tickets{};
  int64_t appearance_id = 0;
  int64_t current_quest_id = 0;
  std::vector<std::unique_ptr<GenericBoson::Zozo::ItemInfoT>> inventory{};
  int32_t inventory_size = 0;
  CharacterInfoT() = default;
  CharacterInfoT(const CharacterInfoT &o);
  CharacterInfoT(CharacterInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  CharacterInfoT &operator=(CharacterInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct CharacterInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterInfoT NativeTableType;
  typedef CharacterInfoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CharacterInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_USER_ID = 6,
    VT_NAME = 8,
    VT_LEVEL = 10,
    VT_HP = 12,
    VT_HP_MAX = 14,
    VT_MP = 16,
    VT_MP_MAX = 18,
    VT_POSITION = 20,
    VT_STATS = 22,
    VT_TICKETS = 24,
    VT_APPEARANCE_ID = 26,
    VT_CURRENT_QUEST_ID = 28,
    VT_INVENTORY = 30,
    VT_INVENTORY_SIZE = 32
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int64_t user_id() const {
    return GetField<int64_t>(VT_USER_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t hp_max() const {
    return GetField<int32_t>(VT_HP_MAX, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t mp_max() const {
    return GetField<int32_t>(VT_MP_MAX, 0);
  }
  const GenericBoson::Zozo::Vector2F *position() const {
    return GetStruct<const GenericBoson::Zozo::Vector2F *>(VT_POSITION);
  }
  const ::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *> *stats() const {
    return GetPointer<const ::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *> *>(VT_STATS);
  }
  const ::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *> *tickets() const {
    return GetPointer<const ::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *> *>(VT_TICKETS);
  }
  int64_t appearance_id() const {
    return GetField<int64_t>(VT_APPEARANCE_ID, 0);
  }
  int64_t current_quest_id() const {
    return GetField<int64_t>(VT_CURRENT_QUEST_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *inventory() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *>(VT_INVENTORY);
  }
  int32_t inventory_size() const {
    return GetField<int32_t>(VT_INVENTORY_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_USER_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<int32_t>(verifier, VT_HP, 4) &&
           VerifyField<int32_t>(verifier, VT_HP_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_MP, 4) &&
           VerifyField<int32_t>(verifier, VT_MP_MAX, 4) &&
           VerifyField<GenericBoson::Zozo::Vector2F>(verifier, VT_POSITION, 4) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           VerifyOffset(verifier, VT_TICKETS) &&
           verifier.VerifyVector(tickets()) &&
           VerifyField<int64_t>(verifier, VT_APPEARANCE_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_CURRENT_QUEST_ID, 8) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyVector(inventory()) &&
           verifier.VerifyVectorOfTables(inventory()) &&
           VerifyField<int32_t>(verifier, VT_INVENTORY_SIZE, 4) &&
           verifier.EndTable();
  }
  CharacterInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CharacterInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterInfoBuilder {
  typedef CharacterInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_ID, id, 0);
  }
  void add_user_id(int64_t user_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_USER_ID, user_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CharacterInfo::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_LEVEL, level, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_HP, hp, 0);
  }
  void add_hp_max(int32_t hp_max) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_HP_MAX, hp_max, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_MP, mp, 0);
  }
  void add_mp_max(int32_t mp_max) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_MP_MAX, mp_max, 0);
  }
  void add_position(const GenericBoson::Zozo::Vector2F *position) {
    fbb_.AddStruct(CharacterInfo::VT_POSITION, position);
  }
  void add_stats(::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *>> stats) {
    fbb_.AddOffset(CharacterInfo::VT_STATS, stats);
  }
  void add_tickets(::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *>> tickets) {
    fbb_.AddOffset(CharacterInfo::VT_TICKETS, tickets);
  }
  void add_appearance_id(int64_t appearance_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_APPEARANCE_ID, appearance_id, 0);
  }
  void add_current_quest_id(int64_t current_quest_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_CURRENT_QUEST_ID, current_quest_id, 0);
  }
  void add_inventory(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>> inventory) {
    fbb_.AddOffset(CharacterInfo::VT_INVENTORY, inventory);
  }
  void add_inventory_size(int32_t inventory_size) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_INVENTORY_SIZE, inventory_size, 0);
  }
  explicit CharacterInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t hp_max = 0,
    int32_t mp = 0,
    int32_t mp_max = 0,
    const GenericBoson::Zozo::Vector2F *position = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *>> stats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *>> tickets = 0,
    int64_t appearance_id = 0,
    int64_t current_quest_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>> inventory = 0,
    int32_t inventory_size = 0) {
  CharacterInfoBuilder builder_(_fbb);
  builder_.add_current_quest_id(current_quest_id);
  builder_.add_appearance_id(appearance_id);
  builder_.add_user_id(user_id);
  builder_.add_id(id);
  builder_.add_inventory_size(inventory_size);
  builder_.add_inventory(inventory);
  builder_.add_tickets(tickets);
  builder_.add_stats(stats);
  builder_.add_position(position);
  builder_.add_mp_max(mp_max);
  builder_.add_mp(mp);
  builder_.add_hp_max(hp_max);
  builder_.add_hp(hp);
  builder_.add_level(level);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t user_id = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t hp_max = 0,
    int32_t mp = 0,
    int32_t mp_max = 0,
    const GenericBoson::Zozo::Vector2F *position = nullptr,
    const std::vector<GenericBoson::Zozo::StatPair> *stats = nullptr,
    const std::vector<GenericBoson::Zozo::TicketPair> *tickets = nullptr,
    int64_t appearance_id = 0,
    int64_t current_quest_id = 0,
    const std::vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *inventory = nullptr,
    int32_t inventory_size = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto stats__ = stats ? _fbb.CreateVectorOfStructs<GenericBoson::Zozo::StatPair>(*stats) : 0;
  auto tickets__ = tickets ? _fbb.CreateVectorOfStructs<GenericBoson::Zozo::TicketPair>(*tickets) : 0;
  auto inventory__ = inventory ? _fbb.CreateVector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>(*inventory) : 0;
  return GenericBoson::Zozo::CreateCharacterInfo(
      _fbb,
      id,
      user_id,
      name__,
      level,
      hp,
      hp_max,
      mp,
      mp_max,
      position,
      stats__,
      tickets__,
      appearance_id,
      current_quest_id,
      inventory__,
      inventory_size);
}

::flatbuffers::Offset<CharacterInfo> CreateCharacterInfo(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CharacterInfoT::CharacterInfoT(const CharacterInfoT &o)
      : id(o.id),
        user_id(o.user_id),
        name(o.name),
        level(o.level),
        hp(o.hp),
        hp_max(o.hp_max),
        mp(o.mp),
        mp_max(o.mp_max),
        position((o.position) ? new GenericBoson::Zozo::Vector2F(*o.position) : nullptr),
        stats(o.stats),
        tickets(o.tickets),
        appearance_id(o.appearance_id),
        current_quest_id(o.current_quest_id),
        inventory_size(o.inventory_size) {
  inventory.reserve(o.inventory.size());
  for (const auto &inventory_ : o.inventory) { inventory.emplace_back((inventory_) ? new GenericBoson::Zozo::ItemInfoT(*inventory_) : nullptr); }
}

inline CharacterInfoT &CharacterInfoT::operator=(CharacterInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(user_id, o.user_id);
  std::swap(name, o.name);
  std::swap(level, o.level);
  std::swap(hp, o.hp);
  std::swap(hp_max, o.hp_max);
  std::swap(mp, o.mp);
  std::swap(mp_max, o.mp_max);
  std::swap(position, o.position);
  std::swap(stats, o.stats);
  std::swap(tickets, o.tickets);
  std::swap(appearance_id, o.appearance_id);
  std::swap(current_quest_id, o.current_quest_id);
  std::swap(inventory, o.inventory);
  std::swap(inventory_size, o.inventory_size);
  return *this;
}

inline CharacterInfoT *CharacterInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CharacterInfoT>(new CharacterInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CharacterInfo::UnPackTo(CharacterInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = user_id(); _o->user_id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = level(); _o->level = _e; }
  { auto _e = hp(); _o->hp = _e; }
  { auto _e = hp_max(); _o->hp_max = _e; }
  { auto _e = mp(); _o->mp = _e; }
  { auto _e = mp_max(); _o->mp_max = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<GenericBoson::Zozo::Vector2F>(new GenericBoson::Zozo::Vector2F(*_e)); }
  { auto _e = stats(); if (_e) { _o->stats.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stats[_i] = *_e->Get(_i); } } else { _o->stats.resize(0); } }
  { auto _e = tickets(); if (_e) { _o->tickets.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tickets[_i] = *_e->Get(_i); } } else { _o->tickets.resize(0); } }
  { auto _e = appearance_id(); _o->appearance_id = _e; }
  { auto _e = current_quest_id(); _o->current_quest_id = _e; }
  { auto _e = inventory(); if (_e) { _o->inventory.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inventory[_i]) { _e->Get(_i)->UnPackTo(_o->inventory[_i].get(), _resolver); } else { _o->inventory[_i] = std::unique_ptr<GenericBoson::Zozo::ItemInfoT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->inventory.resize(0); } }
  { auto _e = inventory_size(); _o->inventory_size = _e; }
}

inline ::flatbuffers::Offset<CharacterInfo> CharacterInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacterInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfo(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CharacterInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _user_id = _o->user_id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _level = _o->level;
  auto _hp = _o->hp;
  auto _hp_max = _o->hp_max;
  auto _mp = _o->mp;
  auto _mp_max = _o->mp_max;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _stats = _o->stats.size() ? _fbb.CreateVectorOfStructs(_o->stats) : 0;
  auto _tickets = _o->tickets.size() ? _fbb.CreateVectorOfStructs(_o->tickets) : 0;
  auto _appearance_id = _o->appearance_id;
  auto _current_quest_id = _o->current_quest_id;
  auto _inventory = _o->inventory.size() ? _fbb.CreateVector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> (_o->inventory.size(), [](size_t i, _VectorArgs *__va) { return CreateItemInfo(*__va->__fbb, __va->__o->inventory[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inventory_size = _o->inventory_size;
  return GenericBoson::Zozo::CreateCharacterInfo(
      _fbb,
      _id,
      _user_id,
      _name,
      _level,
      _hp,
      _hp_max,
      _mp,
      _mp_max,
      _position,
      _stats,
      _tickets,
      _appearance_id,
      _current_quest_id,
      _inventory,
      _inventory_size);
}

inline const ::flatbuffers::TypeTable *StatTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::StatTypeTable
  };
  static const char * const names[] = {
    "None",
    "MeleeAttack",
    "MeleeDefence",
    "RangeAttack",
    "RangeDefence",
    "MagicAttack",
    "MagicDefence",
    "Agility",
    "Accuracy",
    "Speed"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TicketTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::TicketTypeTable
  };
  static const char * const names[] = {
    "None",
    "CaveDungeon",
    "IslandDungeon"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StatPairTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::StatTypeTable
  };
  static const int64_t values[] = { 0, 8, 16 };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TicketPairTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::TicketTypeTable
  };
  static const int64_t values[] = { 0, 8, 16 };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CharacterInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::Vector2FTypeTable,
    GenericBoson::Zozo::StatPairTypeTable,
    GenericBoson::Zozo::TicketPairTypeTable,
    GenericBoson::Zozo::ItemInfoTypeTable
  };
  static const char * const names[] = {
    "id",
    "user_id",
    "name",
    "level",
    "hp",
    "hp_max",
    "mp",
    "mp_max",
    "position",
    "stats",
    "tickets",
    "appearance_id",
    "current_quest_id",
    "inventory",
    "inventory_size"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace Zozo
}  // namespace GenericBoson

#endif  // FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_
