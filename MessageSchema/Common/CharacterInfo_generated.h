// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_
#define FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Constant_generated.h"
#include "ItemInfo_generated.h"
#include "Type_generated.h"

namespace GenericBoson {
namespace Zozo {

struct StatPair;

struct TicketPair;

struct CharacterInfo;
struct CharacterInfoBuilder;

enum Stat : int32_t {
  Stat_None = 0,
  Stat_MeleeAttack = 1,
  Stat_MeleeDefence = 2,
  Stat_RangeAttack = 3,
  Stat_RangeDefence = 4,
  Stat_MagicAttack = 5,
  Stat_MagicDefence = 6,
  Stat_Agility = 7,
  Stat_Accuracy = 8,
  Stat_Speed = 9,
  Stat_MIN = Stat_None,
  Stat_MAX = Stat_Speed
};

inline const Stat (&EnumValuesStat())[10] {
  static const Stat values[] = {
    Stat_None,
    Stat_MeleeAttack,
    Stat_MeleeDefence,
    Stat_RangeAttack,
    Stat_RangeDefence,
    Stat_MagicAttack,
    Stat_MagicDefence,
    Stat_Agility,
    Stat_Accuracy,
    Stat_Speed
  };
  return values;
}

inline const char * const *EnumNamesStat() {
  static const char * const names[11] = {
    "None",
    "MeleeAttack",
    "MeleeDefence",
    "RangeAttack",
    "RangeDefence",
    "MagicAttack",
    "MagicDefence",
    "Agility",
    "Accuracy",
    "Speed",
    nullptr
  };
  return names;
}

inline const char *EnumNameStat(Stat e) {
  if (::flatbuffers::IsOutRange(e, Stat_None, Stat_Speed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStat()[index];
}

enum Ticket : int32_t {
  Ticket_None = 0,
  Ticket_CaveDungeon = 1,
  Ticket_IslandDungeon = 2,
  Ticket_MIN = Ticket_None,
  Ticket_MAX = Ticket_IslandDungeon
};

inline const Ticket (&EnumValuesTicket())[3] {
  static const Ticket values[] = {
    Ticket_None,
    Ticket_CaveDungeon,
    Ticket_IslandDungeon
  };
  return values;
}

inline const char * const *EnumNamesTicket() {
  static const char * const names[4] = {
    "None",
    "CaveDungeon",
    "IslandDungeon",
    nullptr
  };
  return names;
}

inline const char *EnumNameTicket(Ticket e) {
  if (::flatbuffers::IsOutRange(e, Ticket_None, Ticket_IslandDungeon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTicket()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatPair FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t key_;
  int32_t padding0__;
  int64_t value_;

 public:
  StatPair()
      : key_(0),
        padding0__(0),
        value_(0) {
    (void)padding0__;
  }
  StatPair(GenericBoson::Zozo::Stat _key, int64_t _value)
      : key_(::flatbuffers::EndianScalar(static_cast<int32_t>(_key))),
        padding0__(0),
        value_(::flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
  }
  GenericBoson::Zozo::Stat key() const {
    return static_cast<GenericBoson::Zozo::Stat>(::flatbuffers::EndianScalar(key_));
  }
  int64_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(StatPair, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TicketPair FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t key_;
  int32_t padding0__;
  int64_t value_;

 public:
  TicketPair()
      : key_(0),
        padding0__(0),
        value_(0) {
    (void)padding0__;
  }
  TicketPair(GenericBoson::Zozo::Ticket _key, int64_t _value)
      : key_(::flatbuffers::EndianScalar(static_cast<int32_t>(_key))),
        padding0__(0),
        value_(::flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
  }
  GenericBoson::Zozo::Ticket key() const {
    return static_cast<GenericBoson::Zozo::Ticket>(::flatbuffers::EndianScalar(key_));
  }
  int64_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(TicketPair, 16);

struct CharacterInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_USER_ID = 6,
    VT_PASSWORD = 8,
    VT_HP = 10,
    VT_HP_MAX = 12,
    VT_MP = 14,
    VT_MP_MAX = 16,
    VT_POSITION = 18,
    VT_NAME = 20,
    VT_STATS = 22,
    VT_TICKETS = 24,
    VT_APPEARANCE_ID = 26,
    VT_CURRENT_QUEST_ID = 28,
    VT_INVENTORY = 30,
    VT_INVENTORY_SIZE = 32
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int64_t user_id() const {
    return GetField<int64_t>(VT_USER_ID, 0);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t hp_max() const {
    return GetField<int32_t>(VT_HP_MAX, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t mp_max() const {
    return GetField<int32_t>(VT_MP_MAX, 0);
  }
  const GenericBoson::Zozo::Vector2I *position() const {
    return GetStruct<const GenericBoson::Zozo::Vector2I *>(VT_POSITION);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *> *stats() const {
    return GetPointer<const ::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *> *>(VT_STATS);
  }
  const ::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *> *tickets() const {
    return GetPointer<const ::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *> *>(VT_TICKETS);
  }
  int64_t appearance_id() const {
    return GetField<int64_t>(VT_APPEARANCE_ID, 0);
  }
  int64_t current_quest_id() const {
    return GetField<int64_t>(VT_CURRENT_QUEST_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *inventory() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *>(VT_INVENTORY);
  }
  int32_t inventory_size() const {
    return GetField<int32_t>(VT_INVENTORY_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_USER_ID, 8) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<int32_t>(verifier, VT_HP, 4) &&
           VerifyField<int32_t>(verifier, VT_HP_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_MP, 4) &&
           VerifyField<int32_t>(verifier, VT_MP_MAX, 4) &&
           VerifyField<GenericBoson::Zozo::Vector2I>(verifier, VT_POSITION, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           VerifyOffset(verifier, VT_TICKETS) &&
           verifier.VerifyVector(tickets()) &&
           VerifyField<int64_t>(verifier, VT_APPEARANCE_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_CURRENT_QUEST_ID, 8) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyVector(inventory()) &&
           verifier.VerifyVectorOfTables(inventory()) &&
           VerifyField<int32_t>(verifier, VT_INVENTORY_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct CharacterInfoBuilder {
  typedef CharacterInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_ID, id, 0);
  }
  void add_user_id(int64_t user_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_USER_ID, user_id, 0);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(CharacterInfo::VT_PASSWORD, password);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_HP, hp, 0);
  }
  void add_hp_max(int32_t hp_max) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_HP_MAX, hp_max, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_MP, mp, 0);
  }
  void add_mp_max(int32_t mp_max) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_MP_MAX, mp_max, 0);
  }
  void add_position(const GenericBoson::Zozo::Vector2I *position) {
    fbb_.AddStruct(CharacterInfo::VT_POSITION, position);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CharacterInfo::VT_NAME, name);
  }
  void add_stats(::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *>> stats) {
    fbb_.AddOffset(CharacterInfo::VT_STATS, stats);
  }
  void add_tickets(::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *>> tickets) {
    fbb_.AddOffset(CharacterInfo::VT_TICKETS, tickets);
  }
  void add_appearance_id(int64_t appearance_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_APPEARANCE_ID, appearance_id, 0);
  }
  void add_current_quest_id(int64_t current_quest_id) {
    fbb_.AddElement<int64_t>(CharacterInfo::VT_CURRENT_QUEST_ID, current_quest_id, 0);
  }
  void add_inventory(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>> inventory) {
    fbb_.AddOffset(CharacterInfo::VT_INVENTORY, inventory);
  }
  void add_inventory_size(int32_t inventory_size) {
    fbb_.AddElement<int32_t>(CharacterInfo::VT_INVENTORY_SIZE, inventory_size, 0);
  }
  explicit CharacterInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    int32_t hp = 0,
    int32_t hp_max = 0,
    int32_t mp = 0,
    int32_t mp_max = 0,
    const GenericBoson::Zozo::Vector2I *position = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::StatPair *>> stats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const GenericBoson::Zozo::TicketPair *>> tickets = 0,
    int64_t appearance_id = 0,
    int64_t current_quest_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>> inventory = 0,
    int32_t inventory_size = 0) {
  CharacterInfoBuilder builder_(_fbb);
  builder_.add_current_quest_id(current_quest_id);
  builder_.add_appearance_id(appearance_id);
  builder_.add_user_id(user_id);
  builder_.add_id(id);
  builder_.add_inventory_size(inventory_size);
  builder_.add_inventory(inventory);
  builder_.add_tickets(tickets);
  builder_.add_stats(stats);
  builder_.add_name(name);
  builder_.add_position(position);
  builder_.add_mp_max(mp_max);
  builder_.add_mp(mp);
  builder_.add_hp_max(hp_max);
  builder_.add_hp(hp);
  builder_.add_password(password);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t user_id = 0,
    const char *password = nullptr,
    int32_t hp = 0,
    int32_t hp_max = 0,
    int32_t mp = 0,
    int32_t mp_max = 0,
    const GenericBoson::Zozo::Vector2I *position = nullptr,
    const char *name = nullptr,
    const std::vector<GenericBoson::Zozo::StatPair> *stats = nullptr,
    const std::vector<GenericBoson::Zozo::TicketPair> *tickets = nullptr,
    int64_t appearance_id = 0,
    int64_t current_quest_id = 0,
    const std::vector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>> *inventory = nullptr,
    int32_t inventory_size = 0) {
  auto password__ = password ? _fbb.CreateString(password) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto stats__ = stats ? _fbb.CreateVectorOfStructs<GenericBoson::Zozo::StatPair>(*stats) : 0;
  auto tickets__ = tickets ? _fbb.CreateVectorOfStructs<GenericBoson::Zozo::TicketPair>(*tickets) : 0;
  auto inventory__ = inventory ? _fbb.CreateVector<::flatbuffers::Offset<GenericBoson::Zozo::ItemInfo>>(*inventory) : 0;
  return GenericBoson::Zozo::CreateCharacterInfo(
      _fbb,
      id,
      user_id,
      password__,
      hp,
      hp_max,
      mp,
      mp_max,
      position,
      name__,
      stats__,
      tickets__,
      appearance_id,
      current_quest_id,
      inventory__,
      inventory_size);
}

}  // namespace Zozo
}  // namespace GenericBoson

#endif  // FLATBUFFERS_GENERATED_CHARACTERINFO_GENERICBOSON_ZOZO_H_
