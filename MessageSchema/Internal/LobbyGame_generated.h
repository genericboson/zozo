// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOBBYGAME_GENERICBOSON_ZOZO_H_
#define FLATBUFFERS_GENERATED_LOBBYGAME_GENERICBOSON_ZOZO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Constant_generated.h"
#include "ServerInfo_generated.h"

namespace GenericBoson {
namespace Zozo {

struct RegisterReq;
struct RegisterReqBuilder;
struct RegisterReqT;

struct RegisterAck;
struct RegisterAckBuilder;
struct RegisterAckT;

struct AuthRelayReq;
struct AuthRelayReqBuilder;
struct AuthRelayReqT;

struct AuthRelayAck;
struct AuthRelayAckBuilder;
struct AuthRelayAckT;

struct LobbyGameMessage;
struct LobbyGameMessageBuilder;
struct LobbyGameMessageT;

inline const ::flatbuffers::TypeTable *RegisterReqTypeTable();

inline const ::flatbuffers::TypeTable *RegisterAckTypeTable();

inline const ::flatbuffers::TypeTable *AuthRelayReqTypeTable();

inline const ::flatbuffers::TypeTable *AuthRelayAckTypeTable();

inline const ::flatbuffers::TypeTable *LobbyGameMessageTypeTable();

enum LobbyGamePayload : uint8_t {
  LobbyGamePayload_NONE = 0,
  LobbyGamePayload_RegisterReq = 1,
  LobbyGamePayload_RegisterAck = 2,
  LobbyGamePayload_AuthRelayReq = 3,
  LobbyGamePayload_AuthRelayAck = 4,
  LobbyGamePayload_MIN = LobbyGamePayload_NONE,
  LobbyGamePayload_MAX = LobbyGamePayload_AuthRelayAck
};

inline const LobbyGamePayload (&EnumValuesLobbyGamePayload())[5] {
  static const LobbyGamePayload values[] = {
    LobbyGamePayload_NONE,
    LobbyGamePayload_RegisterReq,
    LobbyGamePayload_RegisterAck,
    LobbyGamePayload_AuthRelayReq,
    LobbyGamePayload_AuthRelayAck
  };
  return values;
}

inline const char * const *EnumNamesLobbyGamePayload() {
  static const char * const names[6] = {
    "NONE",
    "RegisterReq",
    "RegisterAck",
    "AuthRelayReq",
    "AuthRelayAck",
    nullptr
  };
  return names;
}

inline const char *EnumNameLobbyGamePayload(LobbyGamePayload e) {
  if (::flatbuffers::IsOutRange(e, LobbyGamePayload_NONE, LobbyGamePayload_AuthRelayAck)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLobbyGamePayload()[index];
}

template<typename T> struct LobbyGamePayloadTraits {
  static const LobbyGamePayload enum_value = LobbyGamePayload_NONE;
};

template<> struct LobbyGamePayloadTraits<GenericBoson::Zozo::RegisterReq> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_RegisterReq;
};

template<> struct LobbyGamePayloadTraits<GenericBoson::Zozo::RegisterAck> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_RegisterAck;
};

template<> struct LobbyGamePayloadTraits<GenericBoson::Zozo::AuthRelayReq> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_AuthRelayReq;
};

template<> struct LobbyGamePayloadTraits<GenericBoson::Zozo::AuthRelayAck> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_AuthRelayAck;
};

template<typename T> struct LobbyGamePayloadUnionTraits {
  static const LobbyGamePayload enum_value = LobbyGamePayload_NONE;
};

template<> struct LobbyGamePayloadUnionTraits<GenericBoson::Zozo::RegisterReqT> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_RegisterReq;
};

template<> struct LobbyGamePayloadUnionTraits<GenericBoson::Zozo::RegisterAckT> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_RegisterAck;
};

template<> struct LobbyGamePayloadUnionTraits<GenericBoson::Zozo::AuthRelayReqT> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_AuthRelayReq;
};

template<> struct LobbyGamePayloadUnionTraits<GenericBoson::Zozo::AuthRelayAckT> {
  static const LobbyGamePayload enum_value = LobbyGamePayload_AuthRelayAck;
};

struct LobbyGamePayloadUnion {
  LobbyGamePayload type;
  void *value;

  LobbyGamePayloadUnion() : type(LobbyGamePayload_NONE), value(nullptr) {}
  LobbyGamePayloadUnion(LobbyGamePayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(LobbyGamePayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  LobbyGamePayloadUnion(const LobbyGamePayloadUnion &);
  LobbyGamePayloadUnion &operator=(const LobbyGamePayloadUnion &u)
    { LobbyGamePayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  LobbyGamePayloadUnion &operator=(LobbyGamePayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~LobbyGamePayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = LobbyGamePayloadUnionTraits<RT>::enum_value;
    if (type != LobbyGamePayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, LobbyGamePayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  GenericBoson::Zozo::RegisterReqT *AsRegisterReq() {
    return type == LobbyGamePayload_RegisterReq ?
      reinterpret_cast<GenericBoson::Zozo::RegisterReqT *>(value) : nullptr;
  }
  const GenericBoson::Zozo::RegisterReqT *AsRegisterReq() const {
    return type == LobbyGamePayload_RegisterReq ?
      reinterpret_cast<const GenericBoson::Zozo::RegisterReqT *>(value) : nullptr;
  }
  GenericBoson::Zozo::RegisterAckT *AsRegisterAck() {
    return type == LobbyGamePayload_RegisterAck ?
      reinterpret_cast<GenericBoson::Zozo::RegisterAckT *>(value) : nullptr;
  }
  const GenericBoson::Zozo::RegisterAckT *AsRegisterAck() const {
    return type == LobbyGamePayload_RegisterAck ?
      reinterpret_cast<const GenericBoson::Zozo::RegisterAckT *>(value) : nullptr;
  }
  GenericBoson::Zozo::AuthRelayReqT *AsAuthRelayReq() {
    return type == LobbyGamePayload_AuthRelayReq ?
      reinterpret_cast<GenericBoson::Zozo::AuthRelayReqT *>(value) : nullptr;
  }
  const GenericBoson::Zozo::AuthRelayReqT *AsAuthRelayReq() const {
    return type == LobbyGamePayload_AuthRelayReq ?
      reinterpret_cast<const GenericBoson::Zozo::AuthRelayReqT *>(value) : nullptr;
  }
  GenericBoson::Zozo::AuthRelayAckT *AsAuthRelayAck() {
    return type == LobbyGamePayload_AuthRelayAck ?
      reinterpret_cast<GenericBoson::Zozo::AuthRelayAckT *>(value) : nullptr;
  }
  const GenericBoson::Zozo::AuthRelayAckT *AsAuthRelayAck() const {
    return type == LobbyGamePayload_AuthRelayAck ?
      reinterpret_cast<const GenericBoson::Zozo::AuthRelayAckT *>(value) : nullptr;
  }
};

bool VerifyLobbyGamePayload(::flatbuffers::Verifier &verifier, const void *obj, LobbyGamePayload type);
bool VerifyLobbyGamePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct RegisterReqT : public ::flatbuffers::NativeTable {
  typedef RegisterReq TableType;
  int32_t server_id = 0;
};

struct RegisterReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterReqT NativeTableType;
  typedef RegisterReqBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegisterReqTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_ID = 4
  };
  int32_t server_id() const {
    return GetField<int32_t>(VT_SERVER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVER_ID, 4) &&
           verifier.EndTable();
  }
  RegisterReqT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegisterReqT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RegisterReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterReqT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegisterReqBuilder {
  typedef RegisterReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_id(int32_t server_id) {
    fbb_.AddElement<int32_t>(RegisterReq::VT_SERVER_ID, server_id, 0);
  }
  explicit RegisterReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterReq> CreateRegisterReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t server_id = 0) {
  RegisterReqBuilder builder_(_fbb);
  builder_.add_server_id(server_id);
  return builder_.Finish();
}

::flatbuffers::Offset<RegisterReq> CreateRegisterReq(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterReqT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegisterAckT : public ::flatbuffers::NativeTable {
  typedef RegisterAck TableType;
  GenericBoson::Zozo::ResultCode result_code = GenericBoson::Zozo::ResultCode_Success;
  std::string db_ip{};
  std::string db_acount{};
  std::string db_password{};
  std::string db_main_schema{};
  std::string server_name{};
  int32_t db_port = 0;
  int32_t listen_port = 0;
  int32_t server_id = 0;
};

struct RegisterAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegisterAckT NativeTableType;
  typedef RegisterAckBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegisterAckTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT_CODE = 4,
    VT_DB_IP = 6,
    VT_DB_ACOUNT = 8,
    VT_DB_PASSWORD = 10,
    VT_DB_MAIN_SCHEMA = 12,
    VT_SERVER_NAME = 14,
    VT_DB_PORT = 16,
    VT_LISTEN_PORT = 18,
    VT_SERVER_ID = 20
  };
  GenericBoson::Zozo::ResultCode result_code() const {
    return static_cast<GenericBoson::Zozo::ResultCode>(GetField<uint32_t>(VT_RESULT_CODE, 0));
  }
  const ::flatbuffers::String *db_ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DB_IP);
  }
  const ::flatbuffers::String *db_acount() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DB_ACOUNT);
  }
  const ::flatbuffers::String *db_password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DB_PASSWORD);
  }
  const ::flatbuffers::String *db_main_schema() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DB_MAIN_SCHEMA);
  }
  const ::flatbuffers::String *server_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVER_NAME);
  }
  int32_t db_port() const {
    return GetField<int32_t>(VT_DB_PORT, 0);
  }
  int32_t listen_port() const {
    return GetField<int32_t>(VT_LISTEN_PORT, 0);
  }
  int32_t server_id() const {
    return GetField<int32_t>(VT_SERVER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT_CODE, 4) &&
           VerifyOffset(verifier, VT_DB_IP) &&
           verifier.VerifyString(db_ip()) &&
           VerifyOffset(verifier, VT_DB_ACOUNT) &&
           verifier.VerifyString(db_acount()) &&
           VerifyOffset(verifier, VT_DB_PASSWORD) &&
           verifier.VerifyString(db_password()) &&
           VerifyOffset(verifier, VT_DB_MAIN_SCHEMA) &&
           verifier.VerifyString(db_main_schema()) &&
           VerifyOffset(verifier, VT_SERVER_NAME) &&
           verifier.VerifyString(server_name()) &&
           VerifyField<int32_t>(verifier, VT_DB_PORT, 4) &&
           VerifyField<int32_t>(verifier, VT_LISTEN_PORT, 4) &&
           VerifyField<int32_t>(verifier, VT_SERVER_ID, 4) &&
           verifier.EndTable();
  }
  RegisterAckT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegisterAckT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RegisterAck> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegisterAckBuilder {
  typedef RegisterAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result_code(GenericBoson::Zozo::ResultCode result_code) {
    fbb_.AddElement<uint32_t>(RegisterAck::VT_RESULT_CODE, static_cast<uint32_t>(result_code), 0);
  }
  void add_db_ip(::flatbuffers::Offset<::flatbuffers::String> db_ip) {
    fbb_.AddOffset(RegisterAck::VT_DB_IP, db_ip);
  }
  void add_db_acount(::flatbuffers::Offset<::flatbuffers::String> db_acount) {
    fbb_.AddOffset(RegisterAck::VT_DB_ACOUNT, db_acount);
  }
  void add_db_password(::flatbuffers::Offset<::flatbuffers::String> db_password) {
    fbb_.AddOffset(RegisterAck::VT_DB_PASSWORD, db_password);
  }
  void add_db_main_schema(::flatbuffers::Offset<::flatbuffers::String> db_main_schema) {
    fbb_.AddOffset(RegisterAck::VT_DB_MAIN_SCHEMA, db_main_schema);
  }
  void add_server_name(::flatbuffers::Offset<::flatbuffers::String> server_name) {
    fbb_.AddOffset(RegisterAck::VT_SERVER_NAME, server_name);
  }
  void add_db_port(int32_t db_port) {
    fbb_.AddElement<int32_t>(RegisterAck::VT_DB_PORT, db_port, 0);
  }
  void add_listen_port(int32_t listen_port) {
    fbb_.AddElement<int32_t>(RegisterAck::VT_LISTEN_PORT, listen_port, 0);
  }
  void add_server_id(int32_t server_id) {
    fbb_.AddElement<int32_t>(RegisterAck::VT_SERVER_ID, server_id, 0);
  }
  explicit RegisterAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegisterAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegisterAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegisterAck> CreateRegisterAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GenericBoson::Zozo::ResultCode result_code = GenericBoson::Zozo::ResultCode_Success,
    ::flatbuffers::Offset<::flatbuffers::String> db_ip = 0,
    ::flatbuffers::Offset<::flatbuffers::String> db_acount = 0,
    ::flatbuffers::Offset<::flatbuffers::String> db_password = 0,
    ::flatbuffers::Offset<::flatbuffers::String> db_main_schema = 0,
    ::flatbuffers::Offset<::flatbuffers::String> server_name = 0,
    int32_t db_port = 0,
    int32_t listen_port = 0,
    int32_t server_id = 0) {
  RegisterAckBuilder builder_(_fbb);
  builder_.add_server_id(server_id);
  builder_.add_listen_port(listen_port);
  builder_.add_db_port(db_port);
  builder_.add_server_name(server_name);
  builder_.add_db_main_schema(db_main_schema);
  builder_.add_db_password(db_password);
  builder_.add_db_acount(db_acount);
  builder_.add_db_ip(db_ip);
  builder_.add_result_code(result_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegisterAck> CreateRegisterAckDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GenericBoson::Zozo::ResultCode result_code = GenericBoson::Zozo::ResultCode_Success,
    const char *db_ip = nullptr,
    const char *db_acount = nullptr,
    const char *db_password = nullptr,
    const char *db_main_schema = nullptr,
    const char *server_name = nullptr,
    int32_t db_port = 0,
    int32_t listen_port = 0,
    int32_t server_id = 0) {
  auto db_ip__ = db_ip ? _fbb.CreateString(db_ip) : 0;
  auto db_acount__ = db_acount ? _fbb.CreateString(db_acount) : 0;
  auto db_password__ = db_password ? _fbb.CreateString(db_password) : 0;
  auto db_main_schema__ = db_main_schema ? _fbb.CreateString(db_main_schema) : 0;
  auto server_name__ = server_name ? _fbb.CreateString(server_name) : 0;
  return GenericBoson::Zozo::CreateRegisterAck(
      _fbb,
      result_code,
      db_ip__,
      db_acount__,
      db_password__,
      db_main_schema__,
      server_name__,
      db_port,
      listen_port,
      server_id);
}

::flatbuffers::Offset<RegisterAck> CreateRegisterAck(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthRelayReqT : public ::flatbuffers::NativeTable {
  typedef AuthRelayReq TableType;
  int32_t user_id = 0;
  std::string token{};
};

struct AuthRelayReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthRelayReqT NativeTableType;
  typedef AuthRelayReqBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthRelayReqTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_TOKEN = 6
  };
  int32_t user_id() const {
    return GetField<int32_t>(VT_USER_ID, 0);
  }
  const ::flatbuffers::String *token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_USER_ID, 4) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           verifier.EndTable();
  }
  AuthRelayReqT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthRelayReqT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthRelayReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayReqT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthRelayReqBuilder {
  typedef AuthRelayReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(int32_t user_id) {
    fbb_.AddElement<int32_t>(AuthRelayReq::VT_USER_ID, user_id, 0);
  }
  void add_token(::flatbuffers::Offset<::flatbuffers::String> token) {
    fbb_.AddOffset(AuthRelayReq::VT_TOKEN, token);
  }
  explicit AuthRelayReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthRelayReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthRelayReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthRelayReq> CreateAuthRelayReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> token = 0) {
  AuthRelayReqBuilder builder_(_fbb);
  builder_.add_token(token);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AuthRelayReq> CreateAuthRelayReqDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t user_id = 0,
    const char *token = nullptr) {
  auto token__ = token ? _fbb.CreateString(token) : 0;
  return GenericBoson::Zozo::CreateAuthRelayReq(
      _fbb,
      user_id,
      token__);
}

::flatbuffers::Offset<AuthRelayReq> CreateAuthRelayReq(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayReqT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthRelayAckT : public ::flatbuffers::NativeTable {
  typedef AuthRelayAck TableType;
  GenericBoson::Zozo::ResultCode result_code = GenericBoson::Zozo::ResultCode_Success;
};

struct AuthRelayAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthRelayAckT NativeTableType;
  typedef AuthRelayAckBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AuthRelayAckTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT_CODE = 4
  };
  GenericBoson::Zozo::ResultCode result_code() const {
    return static_cast<GenericBoson::Zozo::ResultCode>(GetField<uint32_t>(VT_RESULT_CODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESULT_CODE, 4) &&
           verifier.EndTable();
  }
  AuthRelayAckT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthRelayAckT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthRelayAck> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthRelayAckBuilder {
  typedef AuthRelayAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result_code(GenericBoson::Zozo::ResultCode result_code) {
    fbb_.AddElement<uint32_t>(AuthRelayAck::VT_RESULT_CODE, static_cast<uint32_t>(result_code), 0);
  }
  explicit AuthRelayAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthRelayAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthRelayAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthRelayAck> CreateAuthRelayAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GenericBoson::Zozo::ResultCode result_code = GenericBoson::Zozo::ResultCode_Success) {
  AuthRelayAckBuilder builder_(_fbb);
  builder_.add_result_code(result_code);
  return builder_.Finish();
}

::flatbuffers::Offset<AuthRelayAck> CreateAuthRelayAck(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LobbyGameMessageT : public ::flatbuffers::NativeTable {
  typedef LobbyGameMessage TableType;
  GenericBoson::Zozo::LobbyGamePayloadUnion payload{};
};

struct LobbyGameMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LobbyGameMessageT NativeTableType;
  typedef LobbyGameMessageBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LobbyGameMessageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  GenericBoson::Zozo::LobbyGamePayload payload_type() const {
    return static_cast<GenericBoson::Zozo::LobbyGamePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const GenericBoson::Zozo::RegisterReq *payload_as_RegisterReq() const {
    return payload_type() == GenericBoson::Zozo::LobbyGamePayload_RegisterReq ? static_cast<const GenericBoson::Zozo::RegisterReq *>(payload()) : nullptr;
  }
  const GenericBoson::Zozo::RegisterAck *payload_as_RegisterAck() const {
    return payload_type() == GenericBoson::Zozo::LobbyGamePayload_RegisterAck ? static_cast<const GenericBoson::Zozo::RegisterAck *>(payload()) : nullptr;
  }
  const GenericBoson::Zozo::AuthRelayReq *payload_as_AuthRelayReq() const {
    return payload_type() == GenericBoson::Zozo::LobbyGamePayload_AuthRelayReq ? static_cast<const GenericBoson::Zozo::AuthRelayReq *>(payload()) : nullptr;
  }
  const GenericBoson::Zozo::AuthRelayAck *payload_as_AuthRelayAck() const {
    return payload_type() == GenericBoson::Zozo::LobbyGamePayload_AuthRelayAck ? static_cast<const GenericBoson::Zozo::AuthRelayAck *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyLobbyGamePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  LobbyGameMessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LobbyGameMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LobbyGameMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LobbyGameMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const GenericBoson::Zozo::RegisterReq *LobbyGameMessage::payload_as<GenericBoson::Zozo::RegisterReq>() const {
  return payload_as_RegisterReq();
}

template<> inline const GenericBoson::Zozo::RegisterAck *LobbyGameMessage::payload_as<GenericBoson::Zozo::RegisterAck>() const {
  return payload_as_RegisterAck();
}

template<> inline const GenericBoson::Zozo::AuthRelayReq *LobbyGameMessage::payload_as<GenericBoson::Zozo::AuthRelayReq>() const {
  return payload_as_AuthRelayReq();
}

template<> inline const GenericBoson::Zozo::AuthRelayAck *LobbyGameMessage::payload_as<GenericBoson::Zozo::AuthRelayAck>() const {
  return payload_as_AuthRelayAck();
}

struct LobbyGameMessageBuilder {
  typedef LobbyGameMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(GenericBoson::Zozo::LobbyGamePayload payload_type) {
    fbb_.AddElement<uint8_t>(LobbyGameMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(LobbyGameMessage::VT_PAYLOAD, payload);
  }
  explicit LobbyGameMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LobbyGameMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LobbyGameMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LobbyGameMessage> CreateLobbyGameMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GenericBoson::Zozo::LobbyGamePayload payload_type = GenericBoson::Zozo::LobbyGamePayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  LobbyGameMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

::flatbuffers::Offset<LobbyGameMessage> CreateLobbyGameMessage(::flatbuffers::FlatBufferBuilder &_fbb, const LobbyGameMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RegisterReqT *RegisterReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RegisterReqT>(new RegisterReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegisterReq::UnPackTo(RegisterReqT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_id(); _o->server_id = _e; }
}

inline ::flatbuffers::Offset<RegisterReq> RegisterReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterReqT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegisterReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RegisterReq> CreateRegisterReq(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterReqT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RegisterReqT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _server_id = _o->server_id;
  return GenericBoson::Zozo::CreateRegisterReq(
      _fbb,
      _server_id);
}

inline RegisterAckT *RegisterAck::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RegisterAckT>(new RegisterAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegisterAck::UnPackTo(RegisterAckT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result_code(); _o->result_code = _e; }
  { auto _e = db_ip(); if (_e) _o->db_ip = _e->str(); }
  { auto _e = db_acount(); if (_e) _o->db_acount = _e->str(); }
  { auto _e = db_password(); if (_e) _o->db_password = _e->str(); }
  { auto _e = db_main_schema(); if (_e) _o->db_main_schema = _e->str(); }
  { auto _e = server_name(); if (_e) _o->server_name = _e->str(); }
  { auto _e = db_port(); _o->db_port = _e; }
  { auto _e = listen_port(); _o->listen_port = _e; }
  { auto _e = server_id(); _o->server_id = _e; }
}

inline ::flatbuffers::Offset<RegisterAck> RegisterAck::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegisterAck(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RegisterAck> CreateRegisterAck(::flatbuffers::FlatBufferBuilder &_fbb, const RegisterAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RegisterAckT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result_code = _o->result_code;
  auto _db_ip = _o->db_ip.empty() ? 0 : _fbb.CreateString(_o->db_ip);
  auto _db_acount = _o->db_acount.empty() ? 0 : _fbb.CreateString(_o->db_acount);
  auto _db_password = _o->db_password.empty() ? 0 : _fbb.CreateString(_o->db_password);
  auto _db_main_schema = _o->db_main_schema.empty() ? 0 : _fbb.CreateString(_o->db_main_schema);
  auto _server_name = _o->server_name.empty() ? 0 : _fbb.CreateString(_o->server_name);
  auto _db_port = _o->db_port;
  auto _listen_port = _o->listen_port;
  auto _server_id = _o->server_id;
  return GenericBoson::Zozo::CreateRegisterAck(
      _fbb,
      _result_code,
      _db_ip,
      _db_acount,
      _db_password,
      _db_main_schema,
      _server_name,
      _db_port,
      _listen_port,
      _server_id);
}

inline AuthRelayReqT *AuthRelayReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AuthRelayReqT>(new AuthRelayReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthRelayReq::UnPackTo(AuthRelayReqT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_id(); _o->user_id = _e; }
  { auto _e = token(); if (_e) _o->token = _e->str(); }
}

inline ::flatbuffers::Offset<AuthRelayReq> AuthRelayReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayReqT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthRelayReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthRelayReq> CreateAuthRelayReq(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayReqT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthRelayReqT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _user_id = _o->user_id;
  auto _token = _o->token.empty() ? 0 : _fbb.CreateString(_o->token);
  return GenericBoson::Zozo::CreateAuthRelayReq(
      _fbb,
      _user_id,
      _token);
}

inline AuthRelayAckT *AuthRelayAck::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AuthRelayAckT>(new AuthRelayAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthRelayAck::UnPackTo(AuthRelayAckT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result_code(); _o->result_code = _e; }
}

inline ::flatbuffers::Offset<AuthRelayAck> AuthRelayAck::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayAckT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthRelayAck(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthRelayAck> CreateAuthRelayAck(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRelayAckT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthRelayAckT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result_code = _o->result_code;
  return GenericBoson::Zozo::CreateAuthRelayAck(
      _fbb,
      _result_code);
}

inline LobbyGameMessageT *LobbyGameMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LobbyGameMessageT>(new LobbyGameMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LobbyGameMessage::UnPackTo(LobbyGameMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = GenericBoson::Zozo::LobbyGamePayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<LobbyGameMessage> LobbyGameMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LobbyGameMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLobbyGameMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LobbyGameMessage> CreateLobbyGameMessage(::flatbuffers::FlatBufferBuilder &_fbb, const LobbyGameMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LobbyGameMessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return GenericBoson::Zozo::CreateLobbyGameMessage(
      _fbb,
      _payload_type,
      _payload);
}

inline bool VerifyLobbyGamePayload(::flatbuffers::Verifier &verifier, const void *obj, LobbyGamePayload type) {
  switch (type) {
    case LobbyGamePayload_NONE: {
      return true;
    }
    case LobbyGamePayload_RegisterReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterReq *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LobbyGamePayload_RegisterAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LobbyGamePayload_AuthRelayReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayReq *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LobbyGamePayload_AuthRelayAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLobbyGamePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLobbyGamePayload(
        verifier,  values->Get(i), types->GetEnum<LobbyGamePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *LobbyGamePayloadUnion::UnPack(const void *obj, LobbyGamePayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case LobbyGamePayload_RegisterReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterReq *>(obj);
      return ptr->UnPack(resolver);
    }
    case LobbyGamePayload_RegisterAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterAck *>(obj);
      return ptr->UnPack(resolver);
    }
    case LobbyGamePayload_AuthRelayReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayReq *>(obj);
      return ptr->UnPack(resolver);
    }
    case LobbyGamePayload_AuthRelayAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayAck *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> LobbyGamePayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case LobbyGamePayload_RegisterReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterReqT *>(value);
      return CreateRegisterReq(_fbb, ptr, _rehasher).Union();
    }
    case LobbyGamePayload_RegisterAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::RegisterAckT *>(value);
      return CreateRegisterAck(_fbb, ptr, _rehasher).Union();
    }
    case LobbyGamePayload_AuthRelayReq: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayReqT *>(value);
      return CreateAuthRelayReq(_fbb, ptr, _rehasher).Union();
    }
    case LobbyGamePayload_AuthRelayAck: {
      auto ptr = reinterpret_cast<const GenericBoson::Zozo::AuthRelayAckT *>(value);
      return CreateAuthRelayAck(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline LobbyGamePayloadUnion::LobbyGamePayloadUnion(const LobbyGamePayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case LobbyGamePayload_RegisterReq: {
      value = new GenericBoson::Zozo::RegisterReqT(*reinterpret_cast<GenericBoson::Zozo::RegisterReqT *>(u.value));
      break;
    }
    case LobbyGamePayload_RegisterAck: {
      value = new GenericBoson::Zozo::RegisterAckT(*reinterpret_cast<GenericBoson::Zozo::RegisterAckT *>(u.value));
      break;
    }
    case LobbyGamePayload_AuthRelayReq: {
      value = new GenericBoson::Zozo::AuthRelayReqT(*reinterpret_cast<GenericBoson::Zozo::AuthRelayReqT *>(u.value));
      break;
    }
    case LobbyGamePayload_AuthRelayAck: {
      value = new GenericBoson::Zozo::AuthRelayAckT(*reinterpret_cast<GenericBoson::Zozo::AuthRelayAckT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void LobbyGamePayloadUnion::Reset() {
  switch (type) {
    case LobbyGamePayload_RegisterReq: {
      auto ptr = reinterpret_cast<GenericBoson::Zozo::RegisterReqT *>(value);
      delete ptr;
      break;
    }
    case LobbyGamePayload_RegisterAck: {
      auto ptr = reinterpret_cast<GenericBoson::Zozo::RegisterAckT *>(value);
      delete ptr;
      break;
    }
    case LobbyGamePayload_AuthRelayReq: {
      auto ptr = reinterpret_cast<GenericBoson::Zozo::AuthRelayReqT *>(value);
      delete ptr;
      break;
    }
    case LobbyGamePayload_AuthRelayAck: {
      auto ptr = reinterpret_cast<GenericBoson::Zozo::AuthRelayAckT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = LobbyGamePayload_NONE;
}

inline const ::flatbuffers::TypeTable *LobbyGamePayloadTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::RegisterReqTypeTable,
    GenericBoson::Zozo::RegisterAckTypeTable,
    GenericBoson::Zozo::AuthRelayReqTypeTable,
    GenericBoson::Zozo::AuthRelayAckTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RegisterReq",
    "RegisterAck",
    "AuthRelayReq",
    "AuthRelayAck"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RegisterReqTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "server_id"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RegisterAckTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::ResultCodeTypeTable
  };
  static const char * const names[] = {
    "result_code",
    "db_ip",
    "db_acount",
    "db_password",
    "db_main_schema",
    "server_name",
    "db_port",
    "listen_port",
    "server_id"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AuthRelayReqTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "user_id",
    "token"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AuthRelayAckTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::ResultCodeTypeTable
  };
  static const char * const names[] = {
    "result_code"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *LobbyGameMessageTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    GenericBoson::Zozo::LobbyGamePayloadTypeTable
  };
  static const char * const names[] = {
    "payload_type",
    "payload"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const GenericBoson::Zozo::LobbyGameMessage *GetLobbyGameMessage(const void *buf) {
  return ::flatbuffers::GetRoot<GenericBoson::Zozo::LobbyGameMessage>(buf);
}

inline const GenericBoson::Zozo::LobbyGameMessage *GetSizePrefixedLobbyGameMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GenericBoson::Zozo::LobbyGameMessage>(buf);
}

inline bool VerifyLobbyGameMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GenericBoson::Zozo::LobbyGameMessage>(nullptr);
}

inline bool VerifySizePrefixedLobbyGameMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GenericBoson::Zozo::LobbyGameMessage>(nullptr);
}

inline void FinishLobbyGameMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GenericBoson::Zozo::LobbyGameMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLobbyGameMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GenericBoson::Zozo::LobbyGameMessage> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<GenericBoson::Zozo::LobbyGameMessageT> UnPackLobbyGameMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GenericBoson::Zozo::LobbyGameMessageT>(GetLobbyGameMessage(buf)->UnPack(res));
}

inline std::unique_ptr<GenericBoson::Zozo::LobbyGameMessageT> UnPackSizePrefixedLobbyGameMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GenericBoson::Zozo::LobbyGameMessageT>(GetSizePrefixedLobbyGameMessage(buf)->UnPack(res));
}

}  // namespace Zozo
}  // namespace GenericBoson

#endif  // FLATBUFFERS_GENERATED_LOBBYGAME_GENERICBOSON_ZOZO_H_
